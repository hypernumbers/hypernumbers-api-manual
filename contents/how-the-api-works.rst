=================
How The API Works
=================

Introduction
------------

The API works by using a digitally signed ``http`` request (either ``GET`` or ``POST``).

A set of public and private keys is generated on the Hypernumbers site and these are used to sign the requests.

The API is based on the Amazon Web Services digitally signed api. This is because it:

* makes it easy to implement an API
  - using a proven approach developed by a major internet company so that you can confidence that it is robust
* make it easy to generate client libraries for that API so that client-side implementers can:
  - reuse closely related code examples
  - build compatibility unit tests instead of fiddling around debugging their library against live implementations of the system

Get The Source Code
-------------------

The source code for the example client libraries are available from:
TODO

You can also get the source code for the server side implementation and example libraries so you can write tests for your API integration and you don't need to debug against a live system.

Scope
-----

The scope of this section is:

* a description of the client-server exchange
* a reference implementation of
  - the server-side implementation of the exchange
  - the client-side implementation of the exchange
* developing a custom implementation of an API
* deploying that implementation to new client-side users to build their client libraries

Contents
--------

Subsequent parts of this sections are:

* the client-server exchange
* the reference implementation in this example
* building a custom implementation
* deploying a custom implementation

The Client-Server Exchange
--------------------------

**Overview**

This section describes the client-server exchange for the Amazon-style API authentication schema. It has the following characteristics:

* based on a public key/private key
* used to authenticate non-SSL api requests
* not a full once-use schema and is vulnerable to replay attacks within a short time window

.. note:: The client library is based on the Amazon Web Services client library, but it is **not** an Amazon Client Library. Amazon does funky stuff with hostname and pushes them onto the url in canonicalisation. This client library is Amazon-a-like enought to use the Amazon docos to build a test suite.

**Step 1**

The client is issued with a pair of keys, one public, one private, for example:

* public:  ``bcaa49f2a4f7d4f92ac36c8bf66d5bb6``
* private: ``92bc93d6b8aaec1cde772f903e06daf5``

In the Amazon docs these are referred to as:

* ``AWSAccessKeyId``     (public)
* ``AWSSecretAccessKey`` (private)

These can be generated by the erlang function from the example code:

* ``hmac_api_lib:get_api_keypair/0``

Some example output from running this function is:

.. code-block:: erlang

    (hypernumbersdev@hypernumbers.dev)1> hmac_api_lib:get_api_keypair().
    {{public,"1aeb9dba3ef2fbc392a6e6245c9e019b"},
     {private,"1e2850a56b4008d87b2eb43bd7bcd906"}}
    (hypernumbersdev@hypernumbers.dev)2> hmac_api_lib:get_api_keypair().
    {{public,"5846106f93ed5be3a0f2c0ff116f1c79"},
     {private,"181c338bb9351cca7eafdb44abc63040"}}
    (hypernumbersdev@hypernumbers.dev)3> hmac_api_lib:get_api_keypair().
    {{public,"3acc102d0e0a0cbeb06a019733addec8"},
     {private,"1709260540016e2f609edf2b649b4d4c"}}
    (hypernumbersdev@hypernumbers.dev)4> hmac_api_lib:get_api_keypair().
    {{public,"d31b67b2a1c2f980b4dd8fd4f9a9f0ac"},
     {private,"ad1a0588f604fcb05e7c3c0355f838f9"}}

This function returns cryptographically strong random numbers using the openSSL crypto library under the covers.

The public key is used as a declaration of identity, "I am bcaa49..."

The private key is never passed over the wire and is used to construct the same hash on both the client- and the server-side.

**Step 2**

The client prepares their request:

* url
* time of request
* action (``GET``, ``POST``, etc)
* type of request (``application/json``, etc)
* contents of request
* etc, etc

These components are then turned into a string called the canonical form.

The HTTP protocol is permissive; it treats different requests as if they were the same. For instance it doesn't care about the order in which headers are sent, and allows the same header to contain multiple values as a list or be specified multiple times as a key-value pair.

Intermediate machines between the client and server MAY pack and repack the HTTP request as long as they don't alter its meaning in a narrow sense. This means that the format of the HTTP request is not guaranteed to be maintained.

The canonical form simply ensures that all the valid ways of making the same request are represented by the same string - irrespective of how this is done.

The canonical form handles POST bodies and query parameters and silently discards anchors in URL's.

A hash of this string is made with the private key.

The Amazon canonical form allows for the server side to require additional headers - ones that start with a defined header prefix. The client side my, at its discretion add its own headers with this prefix which will be included in the signature.

The hypernumbers server doesn't require any additional headers.

If you wish to use a custom header then add one whose name is prefixed by ``x-mochiapi-``.

The canonical header includes the date taken from the ``date`` header which is set by your underlying http libraries. The date time is checked and there is only an allowable window of 15 minutes in which the API call is valid.

There might be circumstances where you need to specify the date/time manually. In these cases you can override the library date/time values using the header ``x-mochiapi-date``.

Dates **SHOULD** confrom to Section 3.3 of RFC2616.

**Step 3**

The client makes the request to the server:

* the signature is included in the request in the standard HTTPAuthorization header. (As the Amazon documentation points out this is infelicitous as it is being used for Authentication not Authorization, but hey!).

The Authorization header constructed has the form:
``<schema name><space><public key><colon><signature>``

An Amazon one looks like:

``Authorization: AWS 0PN5J17HBGZHT7JJ3X82:frJIUN8DYpKDtOLCwo//yllqDzg=``

The corresponding Hypernumbers one looks like:

``Authorization: MOCHI 0PN5J17HBGZHT7JJ3X82:frJIUN8DYpKDtOLCwo//yllqDzg=``

The HTTP request is made.

**Step 4**

The request is processed:

* the server receives the request
* the server constructs the canonical form from the attributes of the request:
  - url
  - date header
  - action (``GET``, ``POST``, etc)
  - content type of request (``application/json``, etc)
  - some custom headers
  - etc, etc
* the server takes the client's public key from the HTTPAuthorization header and looks up the client's private key
* the server signs the canonical form with the private key
* the server compares:
  - the signature in the request to the signature it has just generated
  - the time encoded in the request with the server time
* the request is accepted or denied

The time comparison is 'fuzzy'. Different server's clocks will be out of sync to a degree, the request may have acquired a time from an intermediate machine along the way, etc, etc. Normally a 'clock skew' time is allowed - in Amazon's case this is 15 minutes.

.. note:: This clock skew time allows for replay attacks where a bad guy simply captures and replays traffic.

The Reference Implementation In This Example
--------------------------------------------

The reference implementation used in this example is that described in the Amazon documentation here:
http://docs.amazonwebservices.com/AmazonS3/latest/dev/index.html?RESTAuthentication.html

Building A Custom Client
------------------------

There are existing client implementations in PHP and Erlang. These client libraries contain definitive sets of tests.

You should write your client library implementing the same test suite.

If you develop an *as-is* client-side library in another language please consider submitting its code to our repository.

Bug fixes or improvements to the existing client libraries will be gratefully accepted.
